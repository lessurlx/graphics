# 计算机视觉导论

本文的主要目的是复盘并总结计算机视觉这个学科常用算法与原理，会从基本的数学理论讲起，同时会附带部分算法的代码实现，由浅入深，只需初中的数学基础就行。主要参考了[GAMES101-现代计算机图形学入门](https://www.bilibili.com/video/BV1X7411F744)这门课，同时附加上自己的理解。有兴趣的同学也可直接看视频。



## 基础铺垫

计算机视觉可大致分为光栅化（Rasterization）、曲线和网格（Curves and Meshes）、光追（Ray Tracing）、动画（Animation / Simulation）这四个方面。其中会着重介绍前3个方面，在此之前，让我们先来了解一些数学知识吧（非常重要，建议不要跳过）



### 向量

![image-20220911154041088](assets/image-20220911154041088.png)

向量的计算公式如下：
$$
\vec{a} = \vec{AB} = B - A
$$
向量有方向和长度，没有绝对位置，将一个向量从坐标系中的一个位置平移到另一个位置，仍然是同一个向量

向量的长度可以这样表示
$$
\begin{Vmatrix}\vec{a} \end{Vmatrix}
$$
在计算过程中，我们总是喜欢用单位向量，即长度为1的向量。它可以暂时忽略长度，只关注方向。那么一个向量的标准化（把普通向量变为单位向量的过程）的计算公式如下：
$$
\widehat{a} = \vec{a} / \begin{Vmatrix} \vec{a} \end{Vmatrix}
$$
如果有两个向量，那么我们也可以对其做一些数学计算

**向量的加法**

平行四边形法则、三角形法则

![image-20220911155113691](assets/image-20220911155113691.png)

向量的减法可以复用这两个法则，如a - b = a + (-b)



 **向量的乘法**

向量的乘法分为点乘和叉乘

**点乘**

![image-20220911155601080](assets/image-20220911155601080.png)

点乘的结果是点积，即乘出来的结果是一个数，表示 $  \vec{a} $  在 $ \vec{b} $ 方向上的**投影**与 $ |\vec{b}| $ 的乘积。它反映了两个向量在方向上的相似度。结果越大越相似。基于结果可以判断这两个向量是否是同一方向，是否正交垂直，具体对应关系为：

![image-20220911160118857](assets/image-20220911160118857.png)

同时点乘满足交换律和分配律，有如下性质

![image-20220911155626605](assets/image-20220911155626605.png)

**叉乘**

叉乘又称向量积，其运算结果是一个向量，并且与这两个向量都**垂直**，是这两个向量所在平面的**法线向量**。使用右手定则确定其方向（右手握拳，四指从A旋转至B，最后大拇指所在方向就是法线方向）。

![image-20220911161210116](assets/image-20220911161210116.png)

叉乘的性质如下（不满足交换律）

![image-20220911161249178](assets/image-20220911161249178.png)

详细计算方法如下

![image-20220911161425397](assets/image-20220911161425397.png)

**可以用叉乘来判断一个点是否在三角形内部**

![image-20220911162450154](assets/image-20220911162450154.png)

根据右手定则可知：AB叉乘AP的结果向外，AB叉乘AC的结果向外，说明点P和点C在AB的同侧；

BC叉乘BP的结果向外，BC叉乘BA的结果向外，说明点P和点A在BC的同侧；

CA叉乘CP的结果向外，CA叉乘CB的结果向外，说明点P和点B在AC的同侧；

综上可知，P在三角形ABC的内部。

若发现点P与任意一个点不在一条边的同侧，则说明该点在三角形外。



**正交**

两个向量正交，就说明两两垂直

![image-20220911163242757](assets/image-20220911163242757.png)



### 矩阵

一个M*N的矩阵就是M行，N列的数
$$
\begin{vmatrix} 0 & 1 \\ 3 & 4 \\ \end{vmatrix}
$$
**矩阵的乘法**

矩阵乘矩阵还是一个矩阵：(M x N) (N x P) = (M x P)

![image-20220911163837928](assets/image-20220911163837928.png)

注意，A的列数必须与B的行数相等才能做矩阵乘法，否则不能乘。



**矩阵的性质**

矩阵满足分配律和结合律，不满足交换律

![image-20220911164120191](assets/image-20220911164120191.png)

**矩阵的转置**

![image-20220911164307519](assets/image-20220911164307519.png)

**逆矩阵**

![image-20220911164430132](assets/image-20220911164430132.png)

**向量的点乘和叉乘都可以用矩阵的形式表示**

![image-20220911165050497](assets/image-20220911165050497.png)

## 变换

### 线性变换

**缩放**

![image-20220911180253408](assets/image-20220911180253408.png)

![image-20220911180323430](assets/image-20220911180323430.png)

**翻转**

![image-20220911180448783](assets/image-20220911180448783.png)

**切变**

![image-20220911180541842](assets/image-20220911180541842.png)

**旋转**

![image-20220911181040497](assets/image-20220911181040497.png)

**总结**：线性变换的方程如下：

![image-20220911181130700](assets/image-20220911181130700.png)

### 齐次坐标

除了上述变换外，还有平移需要考虑。平移的方程如下

![image-20220911191313280](assets/image-20220911191313280.png)

观察这个方程，我们可以看出来，它除了变量x、y之外，还有两个常量。像这种形式的方程，我们没有办法写成矩阵的形式。但很显然，我们并不想有这么个特殊的个例，为了将它写成矩阵的形式，我们可以将它的维度上升，变成三维，即齐次坐标。具体定义如下：

![image-20220911191530709](assets/image-20220911191530709.png)

注：由于向量具有不变性，所以用0表示向量可以保护其在经过一系列变换之后仍能维持不变。

这样表示之后，我们便可以将平移方程转换成矩阵的形式

![image-20220911191626364](assets/image-20220911191626364.png)

我们可以验证这样定义之后，对点和向量之间的运算是否会有影响：

- **向量 + 向量 = 向量 （0 + 0 = 0 ）**
- **点 - 点 = 向量 （1 - 1 = 0）**
- **点 + 向量 = 点 （1 + 0 = 1）**

那么点 + 点等于什么呢？这里需要补充一下，在齐次坐标系中，有如下变换规则

![image-20220911192610224](assets/image-20220911192610224.png)

所以，**点 + 点 = 中点**



### 仿射变换

仿射变换是一个向量空间变换到另一个向量空间的过程。下图指从普通二维向量升维到三维齐次坐标的变换过程

![image-20220911195616117](assets/image-20220911195616117.png)

那么，对上面的二维变换，我们同样可以用齐次坐标的方法来表示

![image-20220911193309870](assets/image-20220911193309870.png)

### 逆变换

逆变换是指将变换复原的过程，很简单，只需要乘上变换矩阵的逆矩阵即可

![image-20220911193355674](assets/image-20220911193355674.png)

### 组合变换

上述几种简单的变换可以组合在一起，形成比较复杂的变换。但是要注意，**矩阵不满足交换律**，所以变换过程的顺序很重要，同样的变换操作，如果顺序不对，就会得到不同的结果。

![image-20220911193908886](assets/image-20220911193908886.png)

**当我们定义好变换操作和顺序之后，我们应该将变换矩阵从右往左写（左乘）**

![image-20220911194358269](assets/image-20220911194358269.png)



### 复杂变换

对于一些比较复杂的变换，比如要求围绕模型的某一个顶点（不在原点）做旋转操作。我们可以将其平移到原点，旋转完之后再平移回去。这一点在后续的3D场景中被广泛运用。

![image-20220911194838447](assets/image-20220911194838447.png)

### 3D变换

3D世界中的变换与2D的类似，依旧是升维成齐次坐标系再做矩阵运算

![image-20220911195136154](assets/image-20220911195136154.png)

![image-20220911195811745](assets/image-20220911195811745.png)

